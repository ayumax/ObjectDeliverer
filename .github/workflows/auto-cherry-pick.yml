name: Auto Cherry-Pick

on:
  push:
    branches:
      - master
    paths-ignore:
      - '.github/cherry-pick-config.yml'
      - '.github/workflows/auto-cherry-pick.yml' 

permissions:
  contents: write
  pull-requests: write

jobs:
  cherry-pick:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod a+x /usr/local/bin/yq

      - name: Read config file
        id: config
        run: |
          if [ -f .github/cherry-pick-config.yml ]; then
            echo "config_exists=true" >> $GITHUB_OUTPUT
            echo "target_branches<<EOF" >> $GITHUB_OUTPUT
            yq -o=json '.target_branches' .github/cherry-pick-config.yml >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "config_exists=false" >> $GITHUB_OUTPUT
            echo "::warning::Config file not found at .github/cherry-pick-config.yml"
          fi

      - name: Set up Git
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"

      - name: Get commit info
        id: commit_info
        run: |
          echo "commit_id=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          echo "commit_message=$(git log -1 --pretty=%B | base64 -w0)" >> $GITHUB_OUTPUT
          echo "commit_author=$(git log -1 --pretty=%an)" >> $GITHUB_OUTPUT
          echo "commit_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Cherry-pick and create PRs
        if: steps.config.outputs.config_exists == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TARGET_BRANCHES: ${{ steps.config.outputs.target_branches }}
          COMMIT_ID: ${{ steps.commit_info.outputs.commit_id }}
          COMMIT_MESSAGE: ${{ steps.commit_info.outputs.commit_message }}
          COMMIT_AUTHOR: ${{ steps.commit_info.outputs.commit_author }}
          COMMIT_SHORT: ${{ steps.commit_info.outputs.commit_short }}
          REPO_NAME: ${{ github.repository }}
        run: |
          # Parse JSON array with JQ
          echo "$TARGET_BRANCHES" | jq -c '.[]' | while read -r branch; do
            # Remove double quotes
            branch=$(echo $branch | tr -d '"')
            echo "Processing branch: $branch"
            
            # Decode commit message
            DECODED_COMMIT_MESSAGE=$(echo "$COMMIT_MESSAGE" | base64 -d)
            
            # Create a new branch for cherry-picking
            # Remove special characters from branch name
            safe_branch=$(echo $branch | sed 's/[^a-zA-Z0-9_-]/_/g')
            cherry_branch="cherry-pick-${COMMIT_SHORT}-to-$safe_branch"
            
            # Check if branch exists
            if ! git ls-remote --heads origin $branch | grep -q $branch; then
              echo "::warning::Branch $branch does not exist, skipping..."
              continue
            fi
            
            # Start fresh
            git checkout -f master
            
            # Checkout target branch with clean state
            git fetch origin $branch:refs/remotes/origin/$branch
            git checkout -B $branch origin/$branch
            
            # Create a new branch for cherry-picking
            git checkout -B $cherry_branch
            
            # Attempt cherry-pick, skip if it fails
            if ! git cherry-pick $COMMIT_ID; then
              echo "::warning::Cherry-pick failed for $branch due to conflicts, skipping..."
              git cherry-pick --abort
              git checkout -f master
              continue
            fi
            
            # Push to remote with force to handle cases where the branch already exists
            if ! git push -f origin $cherry_branch; then
              echo "::error::Failed to push to $cherry_branch"
              git checkout -f master
              continue
            fi
            
            # Set PR title and description (first line of commit message for title)
            PR_TITLE="[Cherry-pick][$branch] $(echo "$DECODED_COMMIT_MESSAGE" | head -n 1)"
            PR_BODY="Cherry-pick of commit $COMMIT_ID from master to $branch.\n\nOriginal commit by: $COMMIT_AUTHOR\nOriginal commit message:\n\n$DECODED_COMMIT_MESSAGE"
            
            # Check if PR already exists
            PR_EXISTS=$(gh pr list --repo "$REPO_NAME" --base "$branch" --head "$cherry_branch" --json number --jq 'length')
            
            if [ "$PR_EXISTS" -eq "0" ]; then
              # Create PR using gh CLI
              if gh pr create --repo "$REPO_NAME" --base "$branch" --head "$cherry_branch" --title "$PR_TITLE" --body "$PR_BODY"; then
                echo "Successfully created PR to $branch"
              else
                echo "::error::Failed to create PR for $branch"
              fi
            else
              echo "PR already exists for $branch, skipping..."
            fi
            
            # Return to master branch
            git checkout -f master
          done

